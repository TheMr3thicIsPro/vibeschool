{"version":3,"sources":["../../../../node_modules/next/src/server/route-modules/app-page/module.compiled.js","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","../../../../src/context/AuthContext.tsx","../../../../src/lib/authListener.ts","../../../../src/lib/ensureProfile.ts"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","'use client';\r\n\r\nimport React, { createContext, useContext, useReducer, useEffect, useRef, useState } from 'react';\r\nimport { getSupabaseClient } from '@/lib/supabase';\r\nimport { initAuthListener } from '@/lib/authListener';\r\nimport { ensureProfile } from '@/lib/ensureProfile';\r\n\r\n// Helper function to add timeout to promises\r\nfunction withTimeout<T>(promise: Promise<T>, ms: number, label: string): Promise<T> {\r\n  return Promise.race([\r\n    promise,\r\n    new Promise<T>((_, reject) => setTimeout(() => reject(new Error(`Timeout: ${label}`)), ms))\r\n  ]) as Promise<T>;\r\n}\r\n\r\ninterface UserState {\r\n  user: any | null;\r\n  session: any | null;\r\n  authLoading: boolean;\r\n  profileLoading: boolean;\r\n  error: string | null;\r\n  profile: any | null;\r\n  authStatus: 'online' | 'offline' | 'checking';\r\n  offlineRetryCount: number;\r\n}\r\n\r\ntype Action =\r\n  | { type: 'SET_USER'; payload: any }\r\n  | { type: 'SET_SESSION'; payload: any }\r\n  | { type: 'SET_AUTH_LOADING'; payload: boolean }\r\n  | { type: 'SET_PROFILE_LOADING'; payload: boolean }\r\n  | { type: 'SET_ERROR'; payload: string | null }\r\n  | { type: 'SET_PROFILE'; payload: any | null }\r\n  | { type: 'SET_AUTH_STATUS'; payload: 'online' | 'offline' | 'checking' }\r\n  | { type: 'INCREMENT_OFFLINE_RETRY' }\r\n  | { type: 'RESET_OFFLINE_RETRY' }\r\n  | { type: 'RESET' };\r\n\r\nconst initialState: UserState = {\r\n  user: null,\r\n  session: null,\r\n  authLoading: true,\r\n  profileLoading: false,\r\n  error: null,\r\n  profile: null,\r\n  authStatus: 'checking',\r\n  offlineRetryCount: 0,\r\n};\r\n\r\nconst AuthContext = createContext<{ state: UserState; dispatch: React.Dispatch<Action>; } | null>(null);\r\n\r\nconst authReducer = (state: UserState, action: Action): UserState => {\r\n  switch (action.type) {\r\n    case 'SET_USER':\r\n      return { ...state, user: action.payload };\r\n    case 'SET_SESSION':\r\n      return { ...state, session: action.payload };\r\n    case 'SET_AUTH_LOADING':\r\n      return { ...state, authLoading: action.payload };\r\n    case 'SET_PROFILE_LOADING':\r\n      return { ...state, profileLoading: action.payload };\r\n    case 'SET_ERROR':\r\n      return { ...state, error: action.payload };\r\n    case 'SET_PROFILE':\r\n      return { ...state, profile: action.payload };\r\n    case 'SET_AUTH_STATUS':\r\n      return { ...state, authStatus: action.payload };\r\n    case 'INCREMENT_OFFLINE_RETRY':\r\n      return { ...state, offlineRetryCount: state.offlineRetryCount + 1 };\r\n    case 'RESET_OFFLINE_RETRY':\r\n      return { ...state, offlineRetryCount: 0 };\r\n    case 'RESET':\r\n      return { ...initialState };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  const [state, dispatch] = useReducer(authReducer, initialState);\r\n  const [hydrated, setHydrated] = useState(false);\r\n  const authSubscriptionRef = useRef<any>(null);\r\n  const broadcastListenerRef = useRef<(() => void) | null>(null);\r\n  const handlingAuthEventRef = useRef(false); // Prevent duplicate auth event handling\r\n  const handledEventRef = useRef<{type: string, userId?: string, ts: number} | null>(null); // Moved to top level\r\n  \r\n  // Offline retry management with refs\r\n  const retryCountRef = useRef(0);\r\n  const retryTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const initInFlightRef = useRef(false);\r\n\r\n  // Hydration guard to avoid triggering effects pre-hydration\r\n  useEffect(() => {\r\n    setHydrated(true);\r\n  }, []);\r\n\r\n  // Initialize auth state on mount\r\n  useEffect(() => {\r\n    // BUILD-TIME GUARD: Skip auth initialization during static build\r\n    if (typeof window === 'undefined') {\r\n      console.log('[AUTH] BUILD-DEBUG: Skipping auth init during build time - window undefined');\r\n      console.log('[AUTH] BUILD-DEBUG: Setting authLoading to false for static render');\r\n      dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n      console.log('[AUTH] BUILD-DEBUG: Auth init skipped successfully');\r\n      return;\r\n    }\r\n    \r\n    if (!hydrated) {\r\n      // Wait for hydration to complete to reduce hydration mismatch risk\r\n      return;\r\n    }\r\n    \r\n    console.log('[AUTH] BUILD-DEBUG: Starting auth initialization - window available');\r\n    \r\n    let retryTimeoutId: NodeJS.Timeout | null = null;\r\n    let isMounted = true;\r\n    \r\n    const initializeAuth = async (isRetry = false) => {\r\n      // Prevent concurrent initialization\r\n      if (initInFlightRef.current) {\r\n        console.log('[AUTH] init already in flight, skipping');\r\n        return;\r\n      }\r\n      \r\n      if (!isMounted) return;\r\n      \r\n      initInFlightRef.current = true;\r\n      \r\n      console.log('[AUTH] init start', { \r\n        isRetry, \r\n        retryCount: retryCountRef.current,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      try {\r\n        // Check reachability FIRST before creating any client\r\n        console.log('[AUTH] supabase url:', process.env.NEXT_PUBLIC_SUPABASE_URL);\r\n        const { testSupabaseReachability } = await import('@/lib/supabase');\r\n        const timeoutMs = process.env.NODE_ENV === 'development' ? 1500 : 5000;\r\n        const reachability = await testSupabaseReachability(process.env.NEXT_PUBLIC_SUPABASE_URL!, timeoutMs);\r\n        \r\n        console.log('[AUTH] reachability result', reachability);\r\n        \r\n        // Be more lenient with reachability - treat AbortError/TypeError (e.g., CORS/blocked) as offline but do not retry aggressively\r\n        const isSoftOffline = reachability.error && (reachability.error.includes('AbortError') || reachability.error.includes('TypeError'));\r\n        \r\n        // Be more lenient with reachability - if we get any response, consider it reachable\r\n        if ((!reachability.ok && reachability.error && !reachability.error.includes('401') && !reachability.error.includes('403')) || isSoftOffline) {\r\n          // Mark as offline BEFORE any client creation\r\n          dispatch({ type: 'SET_AUTH_STATUS', payload: 'offline' });\r\n          dispatch({ type: 'SET_ERROR', payload: `Auth offline: ${reachability.error || 'Cannot reach Supabase'}` });\r\n          dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n          \r\n          // Schedule retry with exponential backoff (max 5 retries in dev to reduce noise)\r\n          const maxRetries = process.env.NODE_ENV === 'development' ? 5 : 10;\r\n          if (!isSoftOffline && retryCountRef.current < maxRetries) {\r\n            retryCountRef.current += 1;\r\n            const delay = Math.min(1000 * Math.pow(2, retryCountRef.current - 1), 10000); // Max 10s\r\n            console.log('[AUTH] offline retry scheduled', { \r\n              attempt: retryCountRef.current, \r\n              delay,\r\n              nextRetry: new Date(Date.now() + delay).toISOString()\r\n            });\r\n            \r\n            // Clear existing timer first\r\n            if (retryTimerRef.current) {\r\n              clearTimeout(retryTimerRef.current);\r\n            }\r\n            \r\n            retryTimerRef.current = setTimeout(() => {\r\n              if (isMounted) {\r\n                initInFlightRef.current = false; // Reset before retry\r\n                initializeAuth(true);\r\n              }\r\n            }, delay);\r\n          } else if (isSoftOffline) {\r\n            console.log('[AUTH] soft offline detected (likely CORS/blocked in IDE). Suppressing aggressive retries.');\r\n          } else {\r\n            console.log('[AUTH] max retry attempts reached, staying offline permanently');\r\n            dispatch({ type: 'SET_ERROR', payload: 'Auth permanently offline: Maximum retry attempts exceeded' });\r\n          }\r\n          \r\n          initInFlightRef.current = false;\r\n          return;\r\n        }\r\n        \r\n        // Online - proceed with auth\r\n        dispatch({ type: 'SET_AUTH_STATUS', payload: 'online' });\r\n        retryCountRef.current = 0; // Reset retry count on successful connection\r\n        \r\n        console.log('[AUTH] getSession start');\r\n        \r\n        // Get client only when online\r\n        const supabase = getSupabaseClient();\r\n        \r\n        // Call supabase.auth.getSession() with timeout 5s\r\n        const sessionResponse: any = await withTimeout(\r\n          supabase.auth.getSession(),\r\n          5000,\r\n          'getSession'\r\n        );\r\n        const { data: { session }, error } = sessionResponse;\r\n        \r\n        if (error) {\r\n          console.error('[AUTH] getSession error', {\r\n            name: error.name,\r\n            message: error.message,\r\n            stack: error.stack?.split('\\n')[0]\r\n          });\r\n          dispatch({ type: 'SET_ERROR', payload: `Auth error: ${error.message}` });\r\n          dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n          return;\r\n        }\r\n        \r\n        console.log('[AUTH] getSession success', { userId: session?.user?.id });\r\n        \r\n        // Set user/session from result\r\n        if (session) {\r\n          dispatch({ type: 'SET_USER', payload: session.user });\r\n          dispatch({ type: 'SET_SESSION', payload: session });\r\n          \r\n          // Kick off profile load in background (do not block authLoading)\r\n          console.log('[AUTH] kicking off profile load');\r\n          void loadProfile(session.user);\r\n        } else {\r\n          console.log('[AUTH] no session found');\r\n        }\r\n        \r\n        // Set authLoading=false ALWAYS\r\n        dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n        \r\n      } catch (error: any) {\r\n        console.error('[AUTH] init failed', {\r\n          name: error.name,\r\n          message: error.message,\r\n          stack: error.stack?.split('\\n')[0]\r\n        });\r\n        \r\n        // Check for network/DNS errors specifically\r\n        if (error.message.includes('Failed to fetch') || error.message.includes('ERR_NAME_NOT_RESOLVED')) {\r\n          dispatch({ type: 'SET_AUTH_STATUS', payload: 'offline' });\r\n          dispatch({ type: 'SET_ERROR', payload: 'Network error: Cannot connect to authentication service. Check your internet connection and Supabase configuration.' });\r\n        } else {\r\n          dispatch({ type: 'SET_ERROR', payload: `Auth initialization failed: ${error.message}` });\r\n        }\r\n        \r\n        dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n      } finally {\r\n        // Always reset the init flag\r\n        initInFlightRef.current = false;\r\n      }\r\n    };\r\n    \r\n    initializeAuth();\r\n\r\n    return () => {\r\n      isMounted = false;\r\n      if (retryTimeoutId) clearTimeout(retryTimeoutId);\r\n      if (retryTimerRef.current) clearTimeout(retryTimerRef.current);\r\n    };\r\n  }, [hydrated]);\r\n\r\n  // Load profile function that runs in background\r\n  const loadProfile = async (user: any) => {\r\n    if (!user?.id) return;\r\n    \r\n    dispatch({ type: 'SET_PROFILE_LOADING', payload: true });\r\n    try {\r\n      console.log('loadProfile start for user:', user.id);\r\n      \r\n      // Create a timeout promise\r\n      const timeoutPromise = new Promise((_, reject) => {\r\n        setTimeout(() => reject(new Error('Timeout: ensureProfile')), 10000);\r\n      });\r\n      \r\n      // Get client for profile loading\r\n      const supabase = getSupabaseClient();\r\n      \r\n      // Race the ensureProfile call against the timeout\r\n      const profile = await Promise.race([\r\n        ensureProfile(supabase, user),\r\n        timeoutPromise\r\n      ]);\r\n      \r\n      // Check if trial has expired for free users\r\n      const isTrialExpired = profile?.plan === 'free' && \r\n                               profile?.trial_expires_at && \r\n                               new Date(profile.trial_expires_at) < new Date();\r\n      \r\n      // Update profile with trial status\r\n      const updatedProfile = {\r\n        ...profile,\r\n        isTrialExpired,\r\n        account_locked: profile?.account_locked || isTrialExpired\r\n      };\r\n      \r\n      dispatch({ type: 'SET_PROFILE', payload: updatedProfile });\r\n      \r\n      // Update user with profile info\r\n      const userWithProfile = {\r\n        ...user,\r\n        role: updatedProfile?.role,\r\n        plan: updatedProfile?.plan,\r\n        username: updatedProfile?.username,\r\n        isTrialExpired: updatedProfile?.isTrialExpired,\r\n        account_locked: updatedProfile?.account_locked\r\n      };\r\n      \r\n      dispatch({ type: 'SET_USER', payload: userWithProfile });\r\n      \r\n      console.log('loadProfile end for user:', user.id);\r\n    } catch (error) {\r\n      console.error('loadProfile error:', error);\r\n      // Still update user even if profile failed\r\n      dispatch({ type: 'SET_ERROR', payload: (error as Error).message });\r\n    } finally {\r\n      dispatch({ type: 'SET_PROFILE_LOADING', payload: false });\r\n    }\r\n  };\r\n\r\n  // Initialize broadcast listener for cross-tab communication\r\n  useEffect(() => {\r\n    let isMounted = true;\r\n  \r\n    broadcastListenerRef.current = initAuthListener(dispatch);\r\n  \r\n    // Listen for auth state changes\r\n    const supabase = getSupabaseClient();\r\n    \r\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: any, session: any) => {\r\n      if (!isMounted) return;\r\n      \r\n      console.log('[AUTH] listener event', { \r\n        type: event, \r\n        userId: session?.user?.id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      // Guard duplicate events using a ref\r\n      const currentUserId = session?.user?.id;\r\n      const now = Date.now();\r\n      \r\n      // ignore duplicate SIGNED_IN fired within 500ms for same userId\r\n      if (handledEventRef.current && \r\n          handledEventRef.current.type === event && \r\n          handledEventRef.current.userId === currentUserId && \r\n          (now - handledEventRef.current.ts) < 500) {\r\n        console.log('AuthProvider: Duplicate event detected, skipping');\r\n        return;\r\n      }\r\n      \r\n      // Prevent duplicate event handling\r\n      if (handlingAuthEventRef.current) {\r\n        console.log('AuthProvider: Auth event already being handled, skipping duplicate');\r\n        return;\r\n      }\r\n      \r\n      handlingAuthEventRef.current = true;\r\n      handledEventRef.current = { type: event, userId: currentUserId, ts: now };\r\n      \r\n      try {\r\n        switch (event) {\r\n          case 'INITIAL_SESSION':\r\n            console.log('AuthProvider: Handling INITIAL_SESSION event');\r\n            if (session) {\r\n              dispatch({ type: 'SET_USER', payload: session.user });\r\n              dispatch({ type: 'SET_SESSION', payload: session });\r\n              \r\n              // Kick off profile load in background\r\n              console.log('AuthProvider: Kicking off profile load in background for INITIAL_SESSION');\r\n              void loadProfile(session.user);\r\n              \r\n              dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n            }\r\n            break;\r\n            \r\n          case 'SIGNED_IN':\r\n            console.log('AuthProvider: Handling SIGNED_IN event for user:', session?.user?.id);\r\n            if (session?.user) {\r\n              dispatch({ type: 'SET_USER', payload: session.user });\r\n              dispatch({ type: 'SET_SESSION', payload: session });\r\n              \r\n              // Kick off profile load in background\r\n              console.log('AuthProvider: Kicking off profile load in background for SIGNED_IN');\r\n              void loadProfile(session.user);\r\n              \r\n              dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n            }\r\n            break;\r\n            \r\n          case 'SIGNED_OUT':\r\n            console.log('AuthProvider: Handling SIGNED_OUT event');\r\n            dispatch({ type: 'RESET' });\r\n            dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n            // Reset the handling flag\r\n            handlingAuthEventRef.current = false;\r\n            break;\r\n            \r\n          case 'TOKEN_REFRESHED':\r\n            console.log('AuthProvider: Handling TOKEN_REFRESHED event');\r\n            if (session) {\r\n              dispatch({ type: 'SET_SESSION', payload: session });\r\n            }\r\n            break;\r\n            \r\n          case 'USER_UPDATED':\r\n            console.log('AuthProvider: Handling USER_UPDATED event');\r\n            if (session?.user) {\r\n              dispatch({ type: 'SET_USER', payload: session.user });\r\n              \r\n              // Kick off profile load in background\r\n              console.log('AuthProvider: Kicking off profile load in background for USER_UPDATED');\r\n              void loadProfile(session.user);\r\n            }\r\n            break;\r\n            \r\n          default:\r\n            console.log('AuthProvider: Unhandled auth event:', event);\r\n        }\r\n      } catch (error) {\r\n        console.error('AuthProvider: Error in auth state change handler:', error);\r\n        dispatch({ type: 'SET_ERROR', payload: (error as Error).message });\r\n      } finally {\r\n        // Always reset the handling flag\r\n        handlingAuthEventRef.current = false;\r\n      }\r\n    });\r\n  \r\n  authSubscriptionRef.current = subscription;\r\n  \r\n  // Clean up on unmount\r\n  return () => {\r\n    isMounted = false;\r\n    initInFlightRef.current = false;\r\n    \r\n    // Clear any pending retry timeouts\r\n    if (retryTimerRef.current) {\r\n      clearTimeout(retryTimerRef.current);\r\n      retryTimerRef.current = null;\r\n      console.log('[AUTH] cleanup: cleared retry timer');\r\n    }\r\n    \r\n    console.log('[AUTH] cleaning up auth subscription');\r\n    if (authSubscriptionRef.current) {\r\n      authSubscriptionRef.current.unsubscribe?.();\r\n      authSubscriptionRef.current = null;\r\n    }\r\n    \r\n    // Clean up broadcast listener\r\n    if (broadcastListenerRef.current) {\r\n      broadcastListenerRef.current();\r\n      broadcastListenerRef.current = null;\r\n    }\r\n    \r\n    // Reset retry count on unmount\r\n    retryCountRef.current = 0;\r\n    console.log('[AUTH] cleanup: reset retry count');\r\n  };\r\n}, []);\r\n\r\n// Ensure the JSX return is inside the component function scope\r\nreturn (\r\n  <AuthContext.Provider value={{ state, dispatch }}>\r\n    {children}\r\n  </AuthContext.Provider>\r\n);\r\n};\r\n\r\nexport const useAuthStore = () => {\r\n  const context = useContext(AuthContext);\r\n  if (context === null) {\r\n    throw new Error('useAuthStore must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Export helper functions for direct access to state\r\nexport const useAuthState = () => {\r\n  const { state } = useAuthStore();\r\n  return state;\r\n};\r\n\r\nexport const useAuthDispatch = () => {\r\n  const { dispatch } = useAuthStore();\r\n  return dispatch;\r\n};","import { supabase } from './supabase';\r\n\r\nlet authListenerInstance: { unsubscribe: () => void } | null = null;\r\n\r\nconst authChannel = new BroadcastChannel('auth');\r\n\r\ninterface AuthBroadcastMessage {\r\n  type: 'AUTH_STATE_CHANGED' | 'TOKEN_REFRESHED' | 'USER_UPDATED' | 'SIGNED_OUT' | 'INITIAL_SESSION';\r\n  userId?: string | null;\r\n  email?: string | null;\r\n}\r\n\r\nexport const initAuthListener = (dispatch: React.Dispatch<any>) => {\r\n  // If already initialized, return the existing cleanup function\r\n  if (authListenerInstance) {\r\n    console.log('Auth listener already initialized, returning existing instance');\r\n    return authListenerInstance.unsubscribe;\r\n  }\r\n\r\n  console.log('Initializing auth listener');\r\n  \r\n  // Listen for messages from other tabs\r\n  authChannel.onmessage = (event) => {\r\n    const message: AuthBroadcastMessage = event.data;\r\n    console.log('Received auth message from other tab:', message);\r\n    \r\n    if (message.type === 'SIGNED_OUT') {\r\n      console.log('Other tab signed out, resetting local state');\r\n      dispatch({ type: 'RESET' });\r\n      \r\n      // Show notification to user\r\n      if (typeof window !== 'undefined') {\r\n        // Create a custom event to notify the UI\r\n        window.dispatchEvent(new CustomEvent('authStateChangeFromOtherTab', {\r\n          detail: { type: 'SIGNED_OUT' }\r\n        }));\r\n      }\r\n    } else if (message.type === 'AUTH_STATE_CHANGED') {\r\n      console.log('Other tab changed auth state, updating local state');\r\n      \r\n      // Show notification to user\r\n      if (message.email) {\r\n        if (typeof window !== 'undefined') {\r\n          // Create a custom event to notify the UI\r\n          window.dispatchEvent(new CustomEvent('authStateChangeFromOtherTab', {\r\n            detail: { \r\n              type: 'AUTH_STATE_CHANGED',\r\n              email: message.email\r\n            }\r\n          }));\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Store the instance to prevent duplicate registration\r\n  authListenerInstance = {\r\n    unsubscribe: () => {\r\n      console.log('Cleaning up auth listener');\r\n      authChannel.close();\r\n      authListenerInstance = null;\r\n    }\r\n  };\r\n\r\n  return authListenerInstance.unsubscribe;\r\n};","import type { SupabaseClient } from \"@supabase/supabase-js\"\r\n\r\nfunction logSupabaseError(context: string, error: any) {\r\n  if (!error) return\r\n  console.error(context, {\r\n    status: error.status,\r\n    code: error.code,\r\n    message: error.message,\r\n    details: error.details,\r\n    hint: error.hint,\r\n  })\r\n}\r\n\r\nexport async function ensureProfile(\r\n  supabase: SupabaseClient,\r\n  user: { id: string; email?: string | null; user_metadata?: any }\r\n) {\r\n  if (!user?.id) throw new Error(\"ensureProfile called without user\")\r\n\r\n  // 1 fetch safely\r\n  const { data: existing, error: fetchError } = await supabase\r\n    .from(\"profiles\")\r\n    .select(\"*\")\r\n    .eq(\"id\", user.id)\r\n    .maybeSingle()\r\n\r\n  if (fetchError) {\r\n    logSupabaseError(\"ensureProfile fetch error\", fetchError)\r\n    throw fetchError\r\n  }\r\n\r\n  if (existing) {\r\n    console.log('ensureProfile: Found existing profile for user:', user.id);\r\n    return existing\r\n  }\r\n\r\n  console.log('ensureProfile: No existing profile found, creating for user:', user.id);\r\n\r\n  // 2 build username fallback safely\r\n  const email = user.email ?? \"\"\r\n  const usernameFromMeta = user.user_metadata?.username\r\n  const usernameFallback =\r\n    (typeof usernameFromMeta === \"string\" && usernameFromMeta.trim()) ||\r\n    (email.includes(\"@\") ? email.split(\"@\")[0] : \"\") ||\r\n    `user_${user.id.slice(0, 8)}`\r\n\r\n  // 3 upsert to avoid 409 if called twice\r\n  const { data: created, error: upsertError } = await supabase\r\n    .from(\"profiles\")\r\n    .upsert(\r\n      {\r\n        id: user.id,\r\n        email: email || null,\r\n        username: usernameFallback,\r\n        role: \"student\",\r\n        plan: \"free\",\r\n        trial_started_at: new Date().toISOString(),\r\n        trial_expires_at: new Date(Date.now() + 1 * 60 * 1000).toISOString(), // 1 minute from now\r\n        account_locked: false\r\n      },\r\n      { onConflict: \"id\" }\r\n    )\r\n    .select(\"*\")\r\n    .single()\r\n\r\n  if (upsertError) {\r\n    logSupabaseError(\"ensureProfile upsert error\", upsertError)\r\n    throw upsertError\r\n  }\r\n\r\n  console.log('ensureProfile: Successfully created profile for user:', user.id);\r\n\r\n  return created\r\n}"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactJsxRuntime","React"],"mappings":"0NA0BQG,EAAOC,OAAO,CAAGC,EAAQ,CAAA,CAAA,IAAA,iCC1BjCF,EAAOC,OAAO,CACZC,EAAQ,CAAA,CAAA,IAAA,GACRI,QAAQ,CAAC,YAAY,CAAEC,eAAe,+BCFxCP,EAAOC,OAAO,CACZC,EAAQ,CAAA,CAAA,IAAA,GACRI,QAAQ,CAAC,YAAY,CAAEE,KAAK,+CCA9B,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OCDA,IAAI,EAA2D,KAEzD,EAAc,IAAI,iBAAiB,QCFzC,SAAS,EAAiB,CAAe,CAAE,CAAU,EAC9C,GACL,IADY,IACJ,KAAK,CAAC,EAAS,CACrB,OAAQ,EAAM,MAAM,CACpB,KAAM,EAAM,IAAI,CAChB,QAAS,EAAM,OAAO,CACtB,QAAS,EAAM,OAAO,CACtB,KAAM,EAAM,IAAI,AAClB,EACF,CAEO,eAAe,EACpB,CAAwB,CACxB,CAAgE,EAEhE,GAAI,CAAC,GAAM,GAAI,MAAM,AAAI,MAAM,qCAG/B,GAAM,CAAE,KAAM,CAAQ,CAAE,MAAO,CAAU,CAAE,CAAG,MAAM,EACjD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,KAAM,EAAK,EAAE,EAChB,WAAW,GAEd,GAAI,EAEF,MADA,EAAiB,EADH,0BACgC,GACxC,EAGR,GAAI,EAEF,OADA,CADY,OACJ,GAAG,CAAC,kDAAmD,EAAK,EAAE,EAC/D,EAGT,QAAQ,GAAG,CAAC,+DAAgE,EAAK,EAAE,EAGnF,IAAM,EAAQ,EAAK,KAAK,EAAI,GACtB,EAAmB,EAAK,aAAa,EAAE,SACvC,EACyB,UAA5B,OAAO,GAAiC,EAAiB,IAAI,KAC7D,CAAD,CAAO,QAAQ,CAAC,KAAO,EAAM,KAAK,CAAC,IAAI,CAAC,EAAE,CAAG,EAAA,CAAE,EAC/C,CAAC,KAAK,EAAE,EAAK,EAAE,CAAC,KAAK,CAAC,EAAG,GAAA,CAAI,CAGzB,CAAE,KAAM,CAAO,CAAE,MAAO,CAAW,CAAE,CAAG,MAAM,EACjD,IAAI,CAAC,YACL,MAAM,CACL,CACE,GAAI,EAAK,EAAE,CACX,MAAO,GAAS,KAChB,SAAU,EACV,KAAM,UACN,KAAM,OACN,iBAAkB,IAAI,OAAO,WAAW,GACxC,iBAAkB,IAAI,KAAK,KAAK,GAAG,GAAK,IAAI,CAAW,IAAN,OAAiB,GAClE,gBAAgB,CAClB,EACA,CAAE,WAAY,IAAK,GAEpB,MAAM,CAAC,KACP,MAAM,GAET,GAAI,EAEF,MADA,EAAiB,GADF,0BACgC,GACzC,EAKR,OAFA,QAAQ,GAAG,CAAC,wDAAyD,EAAK,EAAE,EAErE,CACT,mCFnCA,IAAM,EAA0B,CAC9B,KAAM,KACN,QAAS,KACT,aAAa,EACb,gBAAgB,EAChB,MAAO,KACP,QAAS,KACT,WAAY,WACZ,kBAAmB,CACrB,EAEM,EAAc,CAAA,EAAA,EAAA,aAAA,AAAa,EAAiE,MAE5F,EAAc,CAAC,EAAkB,KACrC,OAAQ,EAAO,IAAI,EACjB,IAAK,WACH,MAAO,CAAE,GAAG,CAAK,CAAE,KAAM,EAAO,OAAO,AAAC,CAC1C,KAAK,cACH,MAAO,CAAE,GAAG,CAAK,CAAE,QAAS,EAAO,OAAO,AAAC,CAC7C,KAAK,mBACH,MAAO,CAAE,GAAG,CAAK,CAAE,YAAa,EAAO,OAAO,AAAC,CACjD,KAAK,sBACH,MAAO,CAAE,GAAG,CAAK,CAAE,eAAgB,EAAO,OAAO,AAAC,CACpD,KAAK,YACH,MAAO,CAAE,GAAG,CAAK,CAAE,MAAO,EAAO,OAAO,AAAC,CAC3C,KAAK,cACH,MAAO,CAAE,GAAG,CAAK,CAAE,QAAS,EAAO,OAAO,AAAC,CAC7C,KAAK,kBACH,MAAO,CAAE,GAAG,CAAK,CAAE,WAAY,EAAO,OAAO,AAAC,CAChD,KAAK,0BACH,MAAO,CAAE,GAAG,CAAK,CAAE,kBAAmB,EAAM,iBAAiB,CAAG,CAAE,CACpE,KAAK,sBACH,MAAO,CAAE,GAAG,CAAK,CAAE,kBAAmB,CAAE,CAC1C,KAAK,QACH,MAAO,CAAE,GAAG,CAAY,AAAC,CAC3B,SACE,OAAO,CACX,CACF,EAwYa,EAAe,KAC1B,IAAM,EAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,GAC3B,GAAgB,AAAZ,MAAkB,GACpB,MAAM,AAAI,MAAM,oDAElB,OAAO,CACT,wBA5YqE,CAAC,UAAE,CAAQ,CAAE,IAChF,GAAM,CAAC,EAAO,EAAS,CAAG,CAAA,EAAA,EAAA,UAAU,AAAV,EAAW,EAAa,GAC5C,CAAC,EAAU,EAAY,CAAG,CAAA,EAAA,EAAA,QAAA,AAAQ,GAAC,GACnC,EAAsB,CAAA,EAAA,EAAA,MAAA,AAAM,EAAM,MAClC,EAAuB,CAAA,EAAA,EAAA,MAAA,AAAM,EAAsB,MACnD,EAAuB,CAAA,EAAA,EAAA,MAAA,AAAM,GAAC,GAC9B,EAAkB,CAAA,EADoB,AACpB,EAAA,MAAA,AAAM,EAAqD,MAG7E,CAHoF,CAGpE,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,GACvB,EAAgB,CAAA,CAJyF,CAIzF,CAL8D,CAK9D,MAAA,AAAM,EAAwB,MAC9C,EAAkB,CAAA,EAAA,EAAA,MAAA,AAAM,GAAC,GAG/B,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KACR,GAAY,EACd,EAAG,EAAE,EAGL,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KAGN,QAAQ,GAAG,CAAC,+EACZ,QAAQ,GAAG,CAAC,sEACZ,EAAS,CAAE,KAAM,mBAAoB,SAAS,CAAM,GACpD,QAAQ,GAAG,CAAC,qDA6JhB,EAAG,CAAC,EAAS,EAGb,IAAM,EAAc,MAAO,IACzB,GAAK,CAAD,EAAO,IAAI,AAEf,EAAS,CAAE,KAAM,sBAAuB,SAAS,CAAK,GACtD,GAAI,CACF,QAAQ,GAAG,CAAC,8BAA+B,EAAK,EAAE,EAGlD,IAAM,EAAiB,IAAI,QAAQ,CAAC,EAAG,KACrC,WAAW,IAAM,EAAO,AAAI,MAAM,2BAA4B,IAChE,GAGM,EAAW,CAAA,EAAA,EAAA,iBAAA,AAAiB,IAG5B,EAAU,MAAM,QAAQ,IAAI,CAAC,CACjC,EAAc,EAAU,GACxB,EACD,EAGK,EAAiB,GAAS,OAAS,QAChB,GAAS,kBACT,IAAI,KAAK,EAAQ,gBAAgB,EAAI,IAAI,KAG5D,EAAiB,CACrB,GAAG,CAAO,gBACV,EACA,eAAgB,GAAS,gBAAkB,CAC7C,EAEA,EAAS,CAAE,KAAM,cAAe,QAAS,CAAe,GAGxD,IAAM,EAAkB,CACtB,GAAG,CAAI,CACP,KAAM,GAAgB,KACtB,KAAM,GAAgB,KACtB,SAAU,GAAgB,SAC1B,eAAgB,GAAgB,eAChC,eAAgB,GAAgB,cAClC,EAEA,EAAS,CAAE,KAAM,WAAY,QAAS,CAAgB,GAEtD,QAAQ,GAAG,CAAC,4BAA6B,EAAK,EAAE,CAClD,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,qBAAsB,GAEpC,EAAS,CAAE,KAAM,YAAa,QAAU,EAAgB,OAAO,AAAC,EAClE,QAAU,CACR,EAAS,CAAE,KAAM,sBAAuB,SAAS,CAAM,EACzD,EACF,EA+IF,MA5IE,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KACR,IAAI,GAAY,CAEhB,GAAqB,OAAO,CCtT1B,AAAJ,EDsTiC,CCrT/B,QAAQ,GAAG,CAAC,OADY,2DAEjB,EAAqB,WAAW,GAGzC,QAAQ,GAAG,CAAC,8BAGZ,EAAY,SAAS,CAAG,AAAC,IACvB,IAAM,EAAgC,EAAM,IAAI,CAChD,QAAQ,GAAG,CAAC,wCAAyC,GAEjD,AAAiB,cAAc,GAAvB,IAAI,EACd,QAAQ,GAAG,CAAC,+CDySkC,ACxS9C,EAAS,CAAE,KAAM,OAAQ,IASC,sBAAsB,CAAvC,EAAQ,IAAI,GACrB,QAAQ,GAAG,CAAC,sDAGR,EAAQ,KAAK,CAYrB,CAZuB,CAuBhB,CARP,EAAuB,CACrB,YAAa,KACX,QAAQ,GAAG,CAAC,6BACZ,EAAY,KAAK,GACjB,EAAuB,IACzB,EACF,EAE4B,WAAW,EDyQrC,GAAM,CAAE,KAAM,cAAE,CAAY,CAAE,CAAE,CAFf,AAEkB,CAFlB,EAAA,EAAA,iBAAiB,AAAjB,IAE2B,IAAI,CAAC,iBAAiB,CAAC,MAAO,EAAY,KACpF,GAAI,CAAC,EAAW,OAEhB,QAAQ,GAAG,CAAC,wBAAyB,CACnC,KAAM,EACN,OAAQ,GAAS,MAAM,GACvB,UAAW,IAAI,OAAO,WAAW,EACnC,GAGA,IAAM,EAAgB,GAAS,MAAM,GAC/B,EAAM,KAAK,GAAG,GAGpB,GAAI,EAAgB,OAAO,EACvB,EAAgB,OAAO,CAAC,IAAI,GAAK,GACjC,EAAgB,OAAO,CAAC,MAAM,GAAK,GAClC,EAAM,EAAgB,OAAO,CAAC,EAAE,CAAI,IAAK,YAC5C,QAAQ,GAAG,CAAC,oDAKd,GAAI,EAAqB,OAAO,CAAE,YAChC,QAAQ,GAAG,CAAC,sEAId,EAAqB,OAAO,EAAG,EAC/B,EAAgB,OAAO,CAAG,CAAE,KAAM,EAAO,OAAQ,EAAe,GAAI,CAAI,EAExE,GAAI,CACF,OAAQ,GACN,IAAK,kBACH,QAAQ,GAAG,CAAC,gDACR,IACF,EAAS,CAAE,EADA,GACM,WAAY,QAAS,EAAQ,IAAK,AAAD,GAClD,EAAS,CAAE,KAAM,cAAe,QAAS,CAAQ,GAGjD,QAAQ,GAAG,CAAC,4EACP,EAAY,EAAQ,IAAI,EAE7B,EAAS,CAAE,KAAM,mBAAoB,SAAS,CAAM,IAEtD,KAEF,KAAK,YACH,QAAQ,GAAG,CAAC,mDAAoD,GAAS,MAAM,IAC3E,GAAS,MAAM,CACjB,EAAS,CAAE,KAAM,WAAY,QAAS,EAAQ,IAAI,AAAC,GACnD,EAAS,CAAE,KAAM,cAAe,QAAS,CAAQ,GAGjD,QAAQ,GAAG,CAAC,sEACP,EAAY,EAAQ,IAAI,EAE7B,EAAS,CAAE,KAAM,mBAAoB,SAAS,CAAM,IAEtD,KAEF,KAAK,aACH,QAAQ,GAAG,CAAC,2CACZ,EAAS,CAAE,KAAM,OAAQ,GACzB,EAAS,CAAE,KAAM,mBAAoB,QAAS,EAAM,GAEpD,EAAqB,OAAO,EAAG,EAC/B,KAEF,KAAK,kBACH,QAAQ,GAAG,CAAC,gDACR,GACF,EAAS,CAAE,GADA,EACM,cAAe,QAAS,CAAQ,GAEnD,KAEF,KAAK,eACH,QAAQ,GAAG,CAAC,6CACR,GAAS,MAAM,CACjB,EAAS,CAAE,KAAM,WAAY,QAAS,EAAQ,IAAI,AAAC,GAGnD,QAAQ,GAAG,CAAC,yEACP,EAAY,EAAQ,IAAI,GAE/B,KAEF,SACE,QAAQ,GAAG,CAAC,sCAAuC,EACvD,CACF,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,oDAAqD,GACnE,EAAS,CAAE,KAAM,YAAa,QAAU,EAAgB,OAAO,AAAC,EAClE,QAAU,CAER,EAAqB,OAAO,EAAG,CACjC,CACF,GAKF,OAHA,EAAoB,OAAO,CAAG,EAGvB,KACL,GAAY,EACZ,EAAgB,OAAO,EAAG,EAGtB,EAAc,OAAO,EAAE,CACzB,aAAa,EAAc,OAAO,EAClC,EAAc,OAAO,CAAG,KACxB,QAAQ,GAAG,CAAC,wCAGd,QAAQ,GAAG,CAAC,wCACR,EAAoB,OAAO,EAAE,CAC/B,EAAoB,OAAO,CAAC,WAAW,KACvC,EAAoB,OAAO,CAAG,MAI5B,EAAqB,OAAO,EAAE,CAChC,EAAqB,OAAO,GAC5B,EAAqB,OAAO,CAAG,MAIjC,EAAc,OAAO,CAAG,EACxB,QAAQ,GAAG,CAAC,oCACd,CACF,EAAG,EAAE,EAIH,CAAA,EAAA,EAAA,GAAA,EAAC,EAAY,QAAQ,CAAA,CAAC,MAAO,OAAE,WAAO,CAAS,WAC5C,GAGL,sBAgB+B,KAC7B,GAAM,CAAE,UAAQ,CAAE,CAAG,IACrB,OAAO,CACT,mBAR4B,KAC1B,GAAM,CAAE,OAAK,CAAE,CAAG,IAClB,OAAO,CACT","ignoreList":[0,1,2]}