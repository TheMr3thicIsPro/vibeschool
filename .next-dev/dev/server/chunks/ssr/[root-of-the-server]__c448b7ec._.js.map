{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ROY0016/.qoder/VibeSchool/vibe-school/src/lib/supabase.ts"],"sourcesContent":["import { createBrowserClient } from '@supabase/ssr';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\r\n\r\n// Dev logs\r\nif (process.env.NODE_ENV === 'development') {\r\n  console.log(\"SUPABASE URL\", supabaseUrl);\r\n  console.log(\"SUPABASE ANON\", supabaseAnonKey ? \"present\" : \"missing\");\r\n}\r\n\r\nif (!supabaseUrl || !supabaseAnonKey) {\r\n  throw new Error(\"Missing Supabase env vars: NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY\")\r\n}\r\nif (!supabaseUrl.startsWith(\"https://\") || !supabaseUrl.includes(\".supabase.co\")) {\r\n  throw new Error(\"Invalid SUPABASE URL format: \" + supabaseUrl)\r\n}\r\n\r\n// Lazy client factory - only create when needed\r\nlet _client: ReturnType<typeof createBrowserClient> | null = null;\r\n\r\nexport function getSupabaseClient() {\r\n  if (!_client) {\r\n    console.log('[AUTH] creating supabase client');\r\n    _client = createBrowserClient(\r\n      supabaseUrl as string, \r\n      supabaseAnonKey as string, \r\n      {\r\n        auth: {\r\n          autoRefreshToken: false, // OFFLINE KILL SWITCH - disable auto refresh\r\n          persistSession: true,\r\n          detectSessionInUrl: false, // Disable URL detection to prevent auto refresh\r\n        }\r\n      }\r\n    );\r\n  }\r\n  return _client;\r\n}\r\n\r\n// Backwards compatibility export - but encourage using getSupabaseClient\r\nexport const supabase = getSupabaseClient();\r\n\r\n// Enhanced reachability test with timeout\r\nexport async function testSupabaseReachability(url: string, timeoutMs = 3000): Promise<{ ok: boolean; error?: string }> {\r\n  console.log('[AUTH] reachability test start', url);\r\n  \r\n  const controller = new AbortController();\r\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\r\n  \r\n  try {\r\n    // Test the base URL instead of health endpoint since health returns 401 without auth\r\n    const testUrl = `${url}/rest/v1/`; // This should return 401 but indicate the server is reachable\r\n    const res = await fetch(testUrl, { \r\n      cache: 'no-store',\r\n      signal: controller.signal,\r\n      method: 'HEAD' // Use HEAD to minimize data transfer\r\n    });\r\n    \r\n    clearTimeout(timeoutId);\r\n    \r\n    console.log('[AUTH] reachability result', { \r\n      status: res.status, \r\n      ok: res.status < 500, // Consider reachable if not 5xx errors\r\n      url: testUrl \r\n    });\r\n    \r\n    // Consider reachable if we get any response (even 401/403) - means server is alive\r\n    const isReachable = res.status > 0 && res.status < 500;\r\n    \r\n    return { \r\n      ok: isReachable, \r\n      error: isReachable ? undefined : `HTTP ${res.status}` \r\n    };\r\n  } catch (error: any) {\r\n    clearTimeout(timeoutId);\r\n    \r\n    console.warn('[AUTH] reachability warning (non-fatal)', {\r\n      name: error.name,\r\n      message: error.message,\r\n      stack: error.stack?.split('\\n')[0],\r\n      url: `${url}/rest/v1/`\r\n    });\r\n    \r\n    return { \r\n      ok: false, \r\n      error: `${error.name}: ${error.message}` \r\n    };\r\n  }\r\n}"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;;AAEA,MAAM;AACN,MAAM;AAEN,WAAW;AACX,wCAA4C;IAC1C,QAAQ,GAAG,CAAC,gBAAgB;IAC5B,QAAQ,GAAG,CAAC,iBAAiB,uCAAkB,YAAY;AAC7D;AAEA;;AAGA,IAAI,CAAC,YAAY,UAAU,CAAC,eAAe,CAAC,YAAY,QAAQ,CAAC,iBAAiB;IAChF,MAAM,IAAI,MAAM,kCAAkC;AACpD;AAEA,gDAAgD;AAChD,IAAI,UAAyD;AAEtD,SAAS;IACd,IAAI,CAAC,SAAS;QACZ,QAAQ,GAAG,CAAC;QACZ,UAAU,IAAA,iMAAmB,EAC3B,aACA,iBACA;YACE,MAAM;gBACJ,kBAAkB;gBAClB,gBAAgB;gBAChB,oBAAoB;YACtB;QACF;IAEJ;IACA,OAAO;AACT;AAGO,MAAM,WAAW;AAGjB,eAAe,yBAAyB,GAAW,EAAE,YAAY,IAAI;IAC1E,QAAQ,GAAG,CAAC,kCAAkC;IAE9C,MAAM,aAAa,IAAI;IACvB,MAAM,YAAY,WAAW,IAAM,WAAW,KAAK,IAAI;IAEvD,IAAI;QACF,qFAAqF;QACrF,MAAM,UAAU,GAAG,IAAI,SAAS,CAAC,EAAE,8DAA8D;QACjG,MAAM,MAAM,MAAM,MAAM,SAAS;YAC/B,OAAO;YACP,QAAQ,WAAW,MAAM;YACzB,QAAQ,OAAO,qCAAqC;QACtD;QAEA,aAAa;QAEb,QAAQ,GAAG,CAAC,8BAA8B;YACxC,QAAQ,IAAI,MAAM;YAClB,IAAI,IAAI,MAAM,GAAG;YACjB,KAAK;QACP;QAEA,mFAAmF;QACnF,MAAM,cAAc,IAAI,MAAM,GAAG,KAAK,IAAI,MAAM,GAAG;QAEnD,OAAO;YACL,IAAI;YACJ,OAAO,cAAc,YAAY,CAAC,KAAK,EAAE,IAAI,MAAM,EAAE;QACvD;IACF,EAAE,OAAO,OAAY;QACnB,aAAa;QAEb,QAAQ,IAAI,CAAC,2CAA2C;YACtD,MAAM,MAAM,IAAI;YAChB,SAAS,MAAM,OAAO;YACtB,OAAO,MAAM,KAAK,EAAE,MAAM,KAAK,CAAC,EAAE;YAClC,KAAK,GAAG,IAAI,SAAS,CAAC;QACxB;QAEA,OAAO;YACL,IAAI;YACJ,OAAO,GAAG,MAAM,IAAI,CAAC,EAAE,EAAE,MAAM,OAAO,EAAE;QAC1C;IACF;AACF"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ROY0016/.qoder/VibeSchool/vibe-school/src/lib/authListener.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nlet authListenerInstance: { unsubscribe: () => void } | null = null;\r\n\r\nconst authChannel = new BroadcastChannel('auth');\r\n\r\ninterface AuthBroadcastMessage {\r\n  type: 'AUTH_STATE_CHANGED' | 'TOKEN_REFRESHED' | 'USER_UPDATED' | 'SIGNED_OUT' | 'INITIAL_SESSION';\r\n  userId?: string | null;\r\n  email?: string | null;\r\n}\r\n\r\nexport const initAuthListener = (dispatch: React.Dispatch<any>) => {\r\n  // If already initialized, return the existing cleanup function\r\n  if (authListenerInstance) {\r\n    console.log('Auth listener already initialized, returning existing instance');\r\n    return authListenerInstance.unsubscribe;\r\n  }\r\n\r\n  console.log('Initializing auth listener');\r\n  \r\n  // Listen for messages from other tabs\r\n  authChannel.onmessage = (event) => {\r\n    const message: AuthBroadcastMessage = event.data;\r\n    console.log('Received auth message from other tab:', message);\r\n    \r\n    if (message.type === 'SIGNED_OUT') {\r\n      console.log('Other tab signed out, resetting local state');\r\n      dispatch({ type: 'RESET' });\r\n      \r\n      // Show notification to user\r\n      if (typeof window !== 'undefined') {\r\n        // Create a custom event to notify the UI\r\n        window.dispatchEvent(new CustomEvent('authStateChangeFromOtherTab', {\r\n          detail: { type: 'SIGNED_OUT' }\r\n        }));\r\n      }\r\n    } else if (message.type === 'AUTH_STATE_CHANGED') {\r\n      console.log('Other tab changed auth state, updating local state');\r\n      \r\n      // Show notification to user\r\n      if (message.email) {\r\n        if (typeof window !== 'undefined') {\r\n          // Create a custom event to notify the UI\r\n          window.dispatchEvent(new CustomEvent('authStateChangeFromOtherTab', {\r\n            detail: { \r\n              type: 'AUTH_STATE_CHANGED',\r\n              email: message.email\r\n            }\r\n          }));\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Store the instance to prevent duplicate registration\r\n  authListenerInstance = {\r\n    unsubscribe: () => {\r\n      console.log('Cleaning up auth listener');\r\n      authChannel.close();\r\n      authListenerInstance = null;\r\n    }\r\n  };\r\n\r\n  return authListenerInstance.unsubscribe;\r\n};"],"names":[],"mappings":";;;;AAEA,IAAI,uBAA2D;AAE/D,MAAM,cAAc,IAAI,iBAAiB;AAQlC,MAAM,mBAAmB,CAAC;IAC/B,+DAA+D;IAC/D,IAAI,sBAAsB;QACxB,QAAQ,GAAG,CAAC;QACZ,OAAO,qBAAqB,WAAW;IACzC;IAEA,QAAQ,GAAG,CAAC;IAEZ,sCAAsC;IACtC,YAAY,SAAS,GAAG,CAAC;QACvB,MAAM,UAAgC,MAAM,IAAI;QAChD,QAAQ,GAAG,CAAC,yCAAyC;QAErD,IAAI,QAAQ,IAAI,KAAK,cAAc;YACjC,QAAQ,GAAG,CAAC;YACZ,SAAS;gBAAE,MAAM;YAAQ;YAEzB,4BAA4B;YAC5B;;QAMF,OAAO,IAAI,QAAQ,IAAI,KAAK,sBAAsB;YAChD,QAAQ,GAAG,CAAC;YAEZ,4BAA4B;YAC5B,IAAI,QAAQ,KAAK,EAAE;gBACjB;;YASF;QACF;IACF;IAEA,uDAAuD;IACvD,uBAAuB;QACrB,aAAa;YACX,QAAQ,GAAG,CAAC;YACZ,YAAY,KAAK;YACjB,uBAAuB;QACzB;IACF;IAEA,OAAO,qBAAqB,WAAW;AACzC"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ROY0016/.qoder/VibeSchool/vibe-school/src/lib/ensureProfile.ts"],"sourcesContent":["import type { SupabaseClient } from \"@supabase/supabase-js\"\r\n\r\nfunction logSupabaseError(context: string, error: any) {\r\n  if (!error) return\r\n  console.error(context, {\r\n    status: error.status,\r\n    code: error.code,\r\n    message: error.message,\r\n    details: error.details,\r\n    hint: error.hint,\r\n  })\r\n}\r\n\r\nexport async function ensureProfile(\r\n  supabase: SupabaseClient,\r\n  user: { id: string; email?: string | null; user_metadata?: any }\r\n) {\r\n  if (!user?.id) throw new Error(\"ensureProfile called without user\")\r\n\r\n  // 1 fetch safely\r\n  const { data: existing, error: fetchError } = await supabase\r\n    .from(\"profiles\")\r\n    .select(\"*\")\r\n    .eq(\"id\", user.id)\r\n    .maybeSingle()\r\n\r\n  if (fetchError) {\r\n    logSupabaseError(\"ensureProfile fetch error\", fetchError)\r\n    throw fetchError\r\n  }\r\n\r\n  if (existing) {\r\n    console.log('ensureProfile: Found existing profile for user:', user.id);\r\n    return existing\r\n  }\r\n\r\n  console.log('ensureProfile: No existing profile found, creating for user:', user.id);\r\n\r\n  // 2 build username fallback safely\r\n  const email = user.email ?? \"\"\r\n  const usernameFromMeta = user.user_metadata?.username\r\n  const usernameFallback =\r\n    (typeof usernameFromMeta === \"string\" && usernameFromMeta.trim()) ||\r\n    (email.includes(\"@\") ? email.split(\"@\")[0] : \"\") ||\r\n    `user_${user.id.slice(0, 8)}`\r\n\r\n  // 3 upsert to avoid 409 if called twice\r\n  const { data: created, error: upsertError } = await supabase\r\n    .from(\"profiles\")\r\n    .upsert(\r\n      {\r\n        id: user.id,\r\n        email: email || null,\r\n        username: usernameFallback,\r\n        role: \"student\",\r\n        plan: \"free\",\r\n        trial_started_at: new Date().toISOString(),\r\n        trial_expires_at: new Date(Date.now() + 1 * 60 * 1000).toISOString(), // 1 minute from now\r\n        account_locked: false\r\n      },\r\n      { onConflict: \"id\" }\r\n    )\r\n    .select(\"*\")\r\n    .single()\r\n\r\n  if (upsertError) {\r\n    logSupabaseError(\"ensureProfile upsert error\", upsertError)\r\n    throw upsertError\r\n  }\r\n\r\n  console.log('ensureProfile: Successfully created profile for user:', user.id);\r\n\r\n  return created\r\n}"],"names":[],"mappings":";;;;AAEA,SAAS,iBAAiB,OAAe,EAAE,KAAU;IACnD,IAAI,CAAC,OAAO;IACZ,QAAQ,KAAK,CAAC,SAAS;QACrB,QAAQ,MAAM,MAAM;QACpB,MAAM,MAAM,IAAI;QAChB,SAAS,MAAM,OAAO;QACtB,SAAS,MAAM,OAAO;QACtB,MAAM,MAAM,IAAI;IAClB;AACF;AAEO,eAAe,cACpB,QAAwB,EACxB,IAAgE;IAEhE,IAAI,CAAC,MAAM,IAAI,MAAM,IAAI,MAAM;IAE/B,iBAAiB;IACjB,MAAM,EAAE,MAAM,QAAQ,EAAE,OAAO,UAAU,EAAE,GAAG,MAAM,SACjD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,KAAK,EAAE,EAChB,WAAW;IAEd,IAAI,YAAY;QACd,iBAAiB,6BAA6B;QAC9C,MAAM;IACR;IAEA,IAAI,UAAU;QACZ,QAAQ,GAAG,CAAC,mDAAmD,KAAK,EAAE;QACtE,OAAO;IACT;IAEA,QAAQ,GAAG,CAAC,gEAAgE,KAAK,EAAE;IAEnF,mCAAmC;IACnC,MAAM,QAAQ,KAAK,KAAK,IAAI;IAC5B,MAAM,mBAAmB,KAAK,aAAa,EAAE;IAC7C,MAAM,mBACJ,AAAC,OAAO,qBAAqB,YAAY,iBAAiB,IAAI,MAC9D,CAAC,MAAM,QAAQ,CAAC,OAAO,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,KAC/C,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,CAAC,GAAG,IAAI;IAE/B,wCAAwC;IACxC,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACjD,IAAI,CAAC,YACL,MAAM,CACL;QACE,IAAI,KAAK,EAAE;QACX,OAAO,SAAS;QAChB,UAAU;QACV,MAAM;QACN,MAAM;QACN,kBAAkB,IAAI,OAAO,WAAW;QACxC,kBAAkB,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,KAAK,MAAM,WAAW;QAClE,gBAAgB;IAClB,GACA;QAAE,YAAY;IAAK,GAEpB,MAAM,CAAC,KACP,MAAM;IAET,IAAI,aAAa;QACf,iBAAiB,8BAA8B;QAC/C,MAAM;IACR;IAEA,QAAQ,GAAG,CAAC,yDAAyD,KAAK,EAAE;IAE5E,OAAO;AACT"}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ROY0016/.qoder/VibeSchool/vibe-school/src/context/AuthContext.tsx"],"sourcesContent":["'use client';\r\n\r\nimport React, { createContext, useContext, useReducer, useEffect, useRef, useState } from 'react';\r\nimport { getSupabaseClient } from '@/lib/supabase';\r\nimport { initAuthListener } from '@/lib/authListener';\r\nimport { ensureProfile } from '@/lib/ensureProfile';\r\n\r\n// Helper function to add timeout to promises\r\nfunction withTimeout<T>(promise: Promise<T>, ms: number, label: string): Promise<T> {\r\n  return Promise.race([\r\n    promise,\r\n    new Promise<T>((_, reject) => setTimeout(() => reject(new Error(`Timeout: ${label}`)), ms))\r\n  ]) as Promise<T>;\r\n}\r\n\r\ninterface UserState {\r\n  user: any | null;\r\n  session: any | null;\r\n  authLoading: boolean;\r\n  profileLoading: boolean;\r\n  error: string | null;\r\n  profile: any | null;\r\n  authStatus: 'online' | 'offline' | 'checking';\r\n  offlineRetryCount: number;\r\n}\r\n\r\ntype Action =\r\n  | { type: 'SET_USER'; payload: any }\r\n  | { type: 'SET_SESSION'; payload: any }\r\n  | { type: 'SET_AUTH_LOADING'; payload: boolean }\r\n  | { type: 'SET_PROFILE_LOADING'; payload: boolean }\r\n  | { type: 'SET_ERROR'; payload: string | null }\r\n  | { type: 'SET_PROFILE'; payload: any | null }\r\n  | { type: 'SET_AUTH_STATUS'; payload: 'online' | 'offline' | 'checking' }\r\n  | { type: 'INCREMENT_OFFLINE_RETRY' }\r\n  | { type: 'RESET_OFFLINE_RETRY' }\r\n  | { type: 'RESET' };\r\n\r\nconst initialState: UserState = {\r\n  user: null,\r\n  session: null,\r\n  authLoading: true,\r\n  profileLoading: false,\r\n  error: null,\r\n  profile: null,\r\n  authStatus: 'checking',\r\n  offlineRetryCount: 0,\r\n};\r\n\r\nconst AuthContext = createContext<{ state: UserState; dispatch: React.Dispatch<Action>; } | null>(null);\r\n\r\nconst authReducer = (state: UserState, action: Action): UserState => {\r\n  switch (action.type) {\r\n    case 'SET_USER':\r\n      return { ...state, user: action.payload };\r\n    case 'SET_SESSION':\r\n      return { ...state, session: action.payload };\r\n    case 'SET_AUTH_LOADING':\r\n      return { ...state, authLoading: action.payload };\r\n    case 'SET_PROFILE_LOADING':\r\n      return { ...state, profileLoading: action.payload };\r\n    case 'SET_ERROR':\r\n      return { ...state, error: action.payload };\r\n    case 'SET_PROFILE':\r\n      return { ...state, profile: action.payload };\r\n    case 'SET_AUTH_STATUS':\r\n      return { ...state, authStatus: action.payload };\r\n    case 'INCREMENT_OFFLINE_RETRY':\r\n      return { ...state, offlineRetryCount: state.offlineRetryCount + 1 };\r\n    case 'RESET_OFFLINE_RETRY':\r\n      return { ...state, offlineRetryCount: 0 };\r\n    case 'RESET':\r\n      return { ...initialState };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  const [state, dispatch] = useReducer(authReducer, initialState);\r\n  const [hydrated, setHydrated] = useState(false);\r\n  const authSubscriptionRef = useRef<any>(null);\r\n  const broadcastListenerRef = useRef<(() => void) | null>(null);\r\n  const handlingAuthEventRef = useRef(false); // Prevent duplicate auth event handling\r\n  const handledEventRef = useRef<{type: string, userId?: string, ts: number} | null>(null); // Moved to top level\r\n  \r\n  // Offline retry management with refs\r\n  const retryCountRef = useRef(0);\r\n  const retryTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const initInFlightRef = useRef(false);\r\n\r\n  // Hydration guard to avoid triggering effects pre-hydration\r\n  useEffect(() => {\r\n    setHydrated(true);\r\n  }, []);\r\n\r\n  // Initialize auth state on mount\r\n  useEffect(() => {\r\n    // BUILD-TIME GUARD: Skip auth initialization during static build\r\n    if (typeof window === 'undefined') {\r\n      console.log('[AUTH] BUILD-DEBUG: Skipping auth init during build time - window undefined');\r\n      console.log('[AUTH] BUILD-DEBUG: Setting authLoading to false for static render');\r\n      dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n      console.log('[AUTH] BUILD-DEBUG: Auth init skipped successfully');\r\n      return;\r\n    }\r\n    \r\n    if (!hydrated) {\r\n      // Wait for hydration to complete to reduce hydration mismatch risk\r\n      return;\r\n    }\r\n    \r\n    console.log('[AUTH] BUILD-DEBUG: Starting auth initialization - window available');\r\n    \r\n    let retryTimeoutId: NodeJS.Timeout | null = null;\r\n    let isMounted = true;\r\n    \r\n    const initializeAuth = async (isRetry = false) => {\r\n      // Prevent concurrent initialization\r\n      if (initInFlightRef.current) {\r\n        console.log('[AUTH] init already in flight, skipping');\r\n        return;\r\n      }\r\n      \r\n      if (!isMounted) return;\r\n      \r\n      initInFlightRef.current = true;\r\n      \r\n      console.log('[AUTH] init start', { \r\n        isRetry, \r\n        retryCount: retryCountRef.current,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      try {\r\n        // Check reachability FIRST before creating any client\r\n        console.log('[AUTH] supabase url:', process.env.NEXT_PUBLIC_SUPABASE_URL);\r\n        const { testSupabaseReachability } = await import('@/lib/supabase');\r\n        const timeoutMs = process.env.NODE_ENV === 'development' ? 1500 : 5000;\r\n        const reachability = await testSupabaseReachability(process.env.NEXT_PUBLIC_SUPABASE_URL!, timeoutMs);\r\n        \r\n        console.log('[AUTH] reachability result', reachability);\r\n        \r\n        // Be more lenient with reachability - treat AbortError/TypeError (e.g., CORS/blocked) as offline but do not retry aggressively\r\n        const isSoftOffline = reachability.error && (reachability.error.includes('AbortError') || reachability.error.includes('TypeError'));\r\n        \r\n        // Be more lenient with reachability - if we get any response, consider it reachable\r\n        if ((!reachability.ok && reachability.error && !reachability.error.includes('401') && !reachability.error.includes('403')) || isSoftOffline) {\r\n          // Mark as offline BEFORE any client creation\r\n          dispatch({ type: 'SET_AUTH_STATUS', payload: 'offline' });\r\n          dispatch({ type: 'SET_ERROR', payload: `Auth offline: ${reachability.error || 'Cannot reach Supabase'}` });\r\n          dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n          \r\n          // Schedule retry with exponential backoff (max 5 retries in dev to reduce noise)\r\n          const maxRetries = process.env.NODE_ENV === 'development' ? 5 : 10;\r\n          if (!isSoftOffline && retryCountRef.current < maxRetries) {\r\n            retryCountRef.current += 1;\r\n            const delay = Math.min(1000 * Math.pow(2, retryCountRef.current - 1), 10000); // Max 10s\r\n            console.log('[AUTH] offline retry scheduled', { \r\n              attempt: retryCountRef.current, \r\n              delay,\r\n              nextRetry: new Date(Date.now() + delay).toISOString()\r\n            });\r\n            \r\n            // Clear existing timer first\r\n            if (retryTimerRef.current) {\r\n              clearTimeout(retryTimerRef.current);\r\n            }\r\n            \r\n            retryTimerRef.current = setTimeout(() => {\r\n              if (isMounted) {\r\n                initInFlightRef.current = false; // Reset before retry\r\n                initializeAuth(true);\r\n              }\r\n            }, delay);\r\n          } else if (isSoftOffline) {\r\n            console.log('[AUTH] soft offline detected (likely CORS/blocked in IDE). Suppressing aggressive retries.');\r\n          } else {\r\n            console.log('[AUTH] max retry attempts reached, staying offline permanently');\r\n            dispatch({ type: 'SET_ERROR', payload: 'Auth permanently offline: Maximum retry attempts exceeded' });\r\n          }\r\n          \r\n          initInFlightRef.current = false;\r\n          return;\r\n        }\r\n        \r\n        // Online - proceed with auth\r\n        dispatch({ type: 'SET_AUTH_STATUS', payload: 'online' });\r\n        retryCountRef.current = 0; // Reset retry count on successful connection\r\n        \r\n        console.log('[AUTH] getSession start');\r\n        \r\n        // Get client only when online\r\n        const supabase = getSupabaseClient();\r\n        \r\n        // Call supabase.auth.getSession() with timeout 5s\r\n        const sessionResponse: any = await withTimeout(\r\n          supabase.auth.getSession(),\r\n          5000,\r\n          'getSession'\r\n        );\r\n        const { data: { session }, error } = sessionResponse;\r\n        \r\n        if (error) {\r\n          console.error('[AUTH] getSession error', {\r\n            name: error.name,\r\n            message: error.message,\r\n            stack: error.stack?.split('\\n')[0]\r\n          });\r\n          dispatch({ type: 'SET_ERROR', payload: `Auth error: ${error.message}` });\r\n          dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n          return;\r\n        }\r\n        \r\n        console.log('[AUTH] getSession success', { userId: session?.user?.id });\r\n        \r\n        // Set user/session from result\r\n        if (session) {\r\n          dispatch({ type: 'SET_USER', payload: session.user });\r\n          dispatch({ type: 'SET_SESSION', payload: session });\r\n          \r\n          // Kick off profile load in background (do not block authLoading)\r\n          console.log('[AUTH] kicking off profile load');\r\n          void loadProfile(session.user);\r\n        } else {\r\n          console.log('[AUTH] no session found');\r\n        }\r\n        \r\n        // Set authLoading=false ALWAYS\r\n        dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n        \r\n      } catch (error: any) {\r\n        console.error('[AUTH] init failed', {\r\n          name: error.name,\r\n          message: error.message,\r\n          stack: error.stack?.split('\\n')[0]\r\n        });\r\n        \r\n        // Check for network/DNS errors specifically\r\n        if (error.message.includes('Failed to fetch') || error.message.includes('ERR_NAME_NOT_RESOLVED')) {\r\n          dispatch({ type: 'SET_AUTH_STATUS', payload: 'offline' });\r\n          dispatch({ type: 'SET_ERROR', payload: 'Network error: Cannot connect to authentication service. Check your internet connection and Supabase configuration.' });\r\n        } else {\r\n          dispatch({ type: 'SET_ERROR', payload: `Auth initialization failed: ${error.message}` });\r\n        }\r\n        \r\n        dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n      } finally {\r\n        // Always reset the init flag\r\n        initInFlightRef.current = false;\r\n      }\r\n    };\r\n    \r\n    initializeAuth();\r\n\r\n    return () => {\r\n      isMounted = false;\r\n      if (retryTimeoutId) clearTimeout(retryTimeoutId);\r\n      if (retryTimerRef.current) clearTimeout(retryTimerRef.current);\r\n    };\r\n  }, [hydrated]);\r\n\r\n  // Load profile function that runs in background\r\n  const loadProfile = async (user: any) => {\r\n    if (!user?.id) return;\r\n    \r\n    dispatch({ type: 'SET_PROFILE_LOADING', payload: true });\r\n    try {\r\n      console.log('loadProfile start for user:', user.id);\r\n      \r\n      // Create a timeout promise\r\n      const timeoutPromise = new Promise((_, reject) => {\r\n        setTimeout(() => reject(new Error('Timeout: ensureProfile')), 10000);\r\n      });\r\n      \r\n      // Get client for profile loading\r\n      const supabase = getSupabaseClient();\r\n      \r\n      // Race the ensureProfile call against the timeout\r\n      const profile = await Promise.race([\r\n        ensureProfile(supabase, user),\r\n        timeoutPromise\r\n      ]);\r\n      \r\n      // Check if trial has expired for free users\r\n      const isTrialExpired = profile?.plan === 'free' && \r\n                               profile?.trial_expires_at && \r\n                               new Date(profile.trial_expires_at) < new Date();\r\n      \r\n      // Update profile with trial status\r\n      const updatedProfile = {\r\n        ...profile,\r\n        isTrialExpired,\r\n        account_locked: profile?.account_locked || isTrialExpired\r\n      };\r\n      \r\n      dispatch({ type: 'SET_PROFILE', payload: updatedProfile });\r\n      \r\n      // Update user with profile info\r\n      const userWithProfile = {\r\n        ...user,\r\n        role: updatedProfile?.role,\r\n        plan: updatedProfile?.plan,\r\n        username: updatedProfile?.username,\r\n        isTrialExpired: updatedProfile?.isTrialExpired,\r\n        account_locked: updatedProfile?.account_locked\r\n      };\r\n      \r\n      dispatch({ type: 'SET_USER', payload: userWithProfile });\r\n      \r\n      console.log('loadProfile end for user:', user.id);\r\n    } catch (error) {\r\n      console.error('loadProfile error:', error);\r\n      // Still update user even if profile failed\r\n      dispatch({ type: 'SET_ERROR', payload: (error as Error).message });\r\n    } finally {\r\n      dispatch({ type: 'SET_PROFILE_LOADING', payload: false });\r\n    }\r\n  };\r\n\r\n  // Initialize broadcast listener for cross-tab communication\r\n  useEffect(() => {\r\n    let isMounted = true;\r\n  \r\n    broadcastListenerRef.current = initAuthListener(dispatch);\r\n  \r\n    // Listen for auth state changes\r\n    const supabase = getSupabaseClient();\r\n    \r\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event: any, session: any) => {\r\n      if (!isMounted) return;\r\n      \r\n      console.log('[AUTH] listener event', { \r\n        type: event, \r\n        userId: session?.user?.id,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      // Guard duplicate events using a ref\r\n      const currentUserId = session?.user?.id;\r\n      const now = Date.now();\r\n      \r\n      // ignore duplicate SIGNED_IN fired within 500ms for same userId\r\n      if (handledEventRef.current && \r\n          handledEventRef.current.type === event && \r\n          handledEventRef.current.userId === currentUserId && \r\n          (now - handledEventRef.current.ts) < 500) {\r\n        console.log('AuthProvider: Duplicate event detected, skipping');\r\n        return;\r\n      }\r\n      \r\n      // Prevent duplicate event handling\r\n      if (handlingAuthEventRef.current) {\r\n        console.log('AuthProvider: Auth event already being handled, skipping duplicate');\r\n        return;\r\n      }\r\n      \r\n      handlingAuthEventRef.current = true;\r\n      handledEventRef.current = { type: event, userId: currentUserId, ts: now };\r\n      \r\n      try {\r\n        switch (event) {\r\n          case 'INITIAL_SESSION':\r\n            console.log('AuthProvider: Handling INITIAL_SESSION event');\r\n            if (session) {\r\n              dispatch({ type: 'SET_USER', payload: session.user });\r\n              dispatch({ type: 'SET_SESSION', payload: session });\r\n              \r\n              // Kick off profile load in background\r\n              console.log('AuthProvider: Kicking off profile load in background for INITIAL_SESSION');\r\n              void loadProfile(session.user);\r\n              \r\n              dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n            }\r\n            break;\r\n            \r\n          case 'SIGNED_IN':\r\n            console.log('AuthProvider: Handling SIGNED_IN event for user:', session?.user?.id);\r\n            if (session?.user) {\r\n              dispatch({ type: 'SET_USER', payload: session.user });\r\n              dispatch({ type: 'SET_SESSION', payload: session });\r\n              \r\n              // Kick off profile load in background\r\n              console.log('AuthProvider: Kicking off profile load in background for SIGNED_IN');\r\n              void loadProfile(session.user);\r\n              \r\n              dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n            }\r\n            break;\r\n            \r\n          case 'SIGNED_OUT':\r\n            console.log('AuthProvider: Handling SIGNED_OUT event');\r\n            dispatch({ type: 'RESET' });\r\n            dispatch({ type: 'SET_AUTH_LOADING', payload: false });\r\n            // Reset the handling flag\r\n            handlingAuthEventRef.current = false;\r\n            break;\r\n            \r\n          case 'TOKEN_REFRESHED':\r\n            console.log('AuthProvider: Handling TOKEN_REFRESHED event');\r\n            if (session) {\r\n              dispatch({ type: 'SET_SESSION', payload: session });\r\n            }\r\n            break;\r\n            \r\n          case 'USER_UPDATED':\r\n            console.log('AuthProvider: Handling USER_UPDATED event');\r\n            if (session?.user) {\r\n              dispatch({ type: 'SET_USER', payload: session.user });\r\n              \r\n              // Kick off profile load in background\r\n              console.log('AuthProvider: Kicking off profile load in background for USER_UPDATED');\r\n              void loadProfile(session.user);\r\n            }\r\n            break;\r\n            \r\n          default:\r\n            console.log('AuthProvider: Unhandled auth event:', event);\r\n        }\r\n      } catch (error) {\r\n        console.error('AuthProvider: Error in auth state change handler:', error);\r\n        dispatch({ type: 'SET_ERROR', payload: (error as Error).message });\r\n      } finally {\r\n        // Always reset the handling flag\r\n        handlingAuthEventRef.current = false;\r\n      }\r\n    });\r\n  \r\n  authSubscriptionRef.current = subscription;\r\n  \r\n  // Clean up on unmount\r\n  return () => {\r\n    isMounted = false;\r\n    initInFlightRef.current = false;\r\n    \r\n    // Clear any pending retry timeouts\r\n    if (retryTimerRef.current) {\r\n      clearTimeout(retryTimerRef.current);\r\n      retryTimerRef.current = null;\r\n      console.log('[AUTH] cleanup: cleared retry timer');\r\n    }\r\n    \r\n    console.log('[AUTH] cleaning up auth subscription');\r\n    if (authSubscriptionRef.current) {\r\n      authSubscriptionRef.current.unsubscribe?.();\r\n      authSubscriptionRef.current = null;\r\n    }\r\n    \r\n    // Clean up broadcast listener\r\n    if (broadcastListenerRef.current) {\r\n      broadcastListenerRef.current();\r\n      broadcastListenerRef.current = null;\r\n    }\r\n    \r\n    // Reset retry count on unmount\r\n    retryCountRef.current = 0;\r\n    console.log('[AUTH] cleanup: reset retry count');\r\n  };\r\n}, []);\r\n\r\n// Ensure the JSX return is inside the component function scope\r\nreturn (\r\n  <AuthContext.Provider value={{ state, dispatch }}>\r\n    {children}\r\n  </AuthContext.Provider>\r\n);\r\n};\r\n\r\nexport const useAuthStore = () => {\r\n  const context = useContext(AuthContext);\r\n  if (context === null) {\r\n    throw new Error('useAuthStore must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Export helper functions for direct access to state\r\nexport const useAuthState = () => {\r\n  const { state } = useAuthStore();\r\n  return state;\r\n};\r\n\r\nexport const useAuthDispatch = () => {\r\n  const { dispatch } = useAuthStore();\r\n  return dispatch;\r\n};"],"names":[],"mappings":"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"}}]
}